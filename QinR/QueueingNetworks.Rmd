---
title: "Statistical Package for Queueing in R"
author: "University of Southern Maine"
date: "9/14/2021"
output:
  html_document: default
  word_document: default
  pdf_document: default
subtitle: Angyalka Valcsics, Pearl Armstrong, Shawn Houser
header-includes:
- \usepackage{placeins}
- \usepackage{bookends}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- https://htmlpreview.github.io/?https://github.com/angyalkavalcsics/QueueingNetworks/blob/main/QueueingNetworks.html -->

## Introduction

Queueing theory is the mathematical study of the formation and function of queues.  A basic queueing system is a system where entities arrive at a facility requiring some service, they join a line, and wait for service from one or more servers. The results of queueing analysis can be used to offer faster customer service, increase traffic flow, improve order shipments from a warehouse, or to design data networks and call centers. In this first demonstration, we will use the random events of arrivals and service completions from a general distribution to demonstrate the development of a queue over time. We assume the reader has some previous knowledge of queueing networks. 

## Measures of System Performance

Variable | Definition
------------- | -------------
$\lambda$  | Average arrival rate
$S$  | Random service time
$\mu$  | Average service rate
$c$  | Number of servers
$r = \lambda / \mu$  | Offered load
$\rho = \lambda / c \mu$  | Traffic intensity or utilization
$T, T_{q}$  | Random time a customer spends in the system / queue
$W, W_{q}$  | Average time a customer spends in the system / queue
$N, N_{q}$  | Random number of customers in the system / queue
$L, L_{q}$  | Average number of customers in the system / queue

## Notation and relationships for G/G/1 queue

In event-oriented bookkeeping, the system state is only updated when events occur. Either when customers/jobs arrive or depart. Suppose we observe a system, recording the times of arrival and service for each entity. An alternative to recording arrival times is to record the time between arrivals. With this information we can calculate measures of performance (see table above) and find other bookkeeping results such as:

Variable | Definition | Sample relationship
------------- | ------------- | -------------
$A^{(n)}$  | Arrival time of cust. $n$ | 
$S^{(n)}$  | Service time of cust. $n$ |
$T^{(n)}$  | Inter. time cust. $n$ and $n+1$ | $T^{(n)} = A^{(n+1)} - A^{(n)}$
$U^{(n)}$  | Time cust. $n$ starts service | $U^{(n+1)} = max\{D^{(n)}, A^{(n+1)}\}$
$D^{(n)}$  |Departure time of cust. $n$ | $D^{(n)} = U^{(n)} + S^{(n)}$
$W_{q}^{(n)}$  | Time in queue of cust. $n$ | $W_{q}^{(n)} = U^{(n)} - A^{(n)}$
$W^{(n)}$  | Time in system of cust. $n$ | $W^{(n)} = W_{q}^{(n)} + S^{(n)}$

The analysis is obtained under the assumption of a single server with FCFS discipline. No assumptions are required on the probability laws for the interarrival times or service times. 

The gg1.summary() function takes three inputs. First an input of either the arrival times or the interarrival times, the service times, and a Boolean--set interarrival = TRUE if the first input is interarrival times. The function outputs a data frame with the bookkeeping values for each entity and a data frame which holds some performance measures.The user can access performance measures by name using the $ operator. Please see the examples that follow.

```{r gg1summary, echo=FALSE }
gg1.summary <- function(arrivals, service_times, interarrival = FALSE){
   if(length(arrivals) != length(service_times))
   {
      stop('Arrays must have equal length')
   }
   n <- length(arrivals)
   if(interarrival == TRUE){
      interarrival_times = c(arrivals, NA)
      service_times = c(NA, service_times)
      arrival_times = c(0)
      arrival_times <- append(arrival_times, interarrival_times[1])
      for(i in 2:n){
         arrival_times <- append(arrival_times, arrival_times[i] + interarrival_times[i])
      }
      starts_service <- c(NA, arrival_times[2])
      departure_times <- c(NA, service_times[2] + arrival_times[2])
      for(i in 3:(n+1)){
         starts_service <- append(starts_service, max(departure_times[i-1], arrival_times[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- c(starts_service - arrival_times)
      system_times <- c(queue_times + service_times)
      df <- data.frame(customers = c(0, seq(1:n)), arrival_times = arrival_times,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times, na.rm = TRUE)
      W <- mean(system_times, na.rm = TRUE)
      lambda <- n/departure_times[n+1]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
      
   }
   else{
      interarrival_times <- c(diff(arrivals), NA)
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrivals[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrivals[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrivals
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrivals = arrivals,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex1}
# Arrival times
arrival <- c(0, 2, 3, 6, 7, 8, 12, 14, 19, 20, 24, 26)
# Service times
service <- c(1, 3, 6, 2, 1, 1, 1, 2, 5, 1, 1, 3)
# Run gg1.summary() on this data
q <- gg1.summary(arrival, service)
# Use gt package for nice tables
library(gt)
# Get bookkeeping results
pt <- q$bookkeeping
pt %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))
```

<br />
Now suppose that we only had data on the interarrival times and the service times. 

```{r ex2}
# Interarrival times
inter <- c(1, 9, 6, 4, 7, 9, 5, 8, 4, 10, 6, 12, 6, 8, 
           9, 5, 7, 8, 8, 7)
# Service times
serv <- c(3, 7, 9, 9, 10, 4, 8, 5, 5, 3, 6, 3, 5, 4, 
          9, 9, 8, 6, 8, 3)
# Run gg1.summary() on this data
q2 <- gg1.summary(inter, serv, interarrival = TRUE)
pt2 <- q2$bookkeeping
pt2 %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt2 <- q2$res
qt2 %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))
```

## The Birth Death Process

Suppose you want to solve the flow balance equation for a birth-death type queue with finite capacity $n$. Given an array of arrival (birth) rates $\lambda = (\lambda_{0}, \lambda_{1}, \cdots)$ and an array of service (death) rates $\mu = (\mu_{1}, \mu_{2}, \cdots)$, the function BD.solve($\lambda$, $\mu$) will return $\{p_n, n \geq 0\}$, the discrete distribution of number of customers in system. Please see the following example with $\lambda = (3, 2, 1)$ and $\mu = (1, 2, 2)$.

```{r BD.solve, echo=FALSE }
BD.solve <- function(lambda, mu){
   if(length(lambda) != length(mu))
   {
      stop('Arrays must have equal length')
   }
   temp = lambda/mu
   k = length(lambda)
   s = 0
   for(j in 1:k){
      s = s + prod(temp[1:j])
   }
   p0 = 1/(1+s)
   pn = c(p0)
   for(j in 1:k){
      pn <- append(pn, temp[j]*pn[j])
   }
   return(pn)
}
```

```{r ex8}
mu = c(1, 2, 2)
lambda = c(3, 2, 1)
pn = BD.solve(lambda, mu)
print(pn)
```
Where the first element corresponds to $p_0$, the second to $p_1$, and so on. 

## M/M/c Markovian model

<br />
Next we consider an M/M/1 Markovian model. Given inputs arrival rate, service rate, and number of servers $c = 1$ the function mm1.summary() returns a data frame of performance measures for the queue and an array with the discrete distribution of number of customers in system. Additionally, by entering "plot_pn = TRUE", the function will plot this distribution. For m/m/1 queues, by entering "plot_waitSys = TRUE" the function will plot the probability density function of the waiting time in system and similarly "plot_waitQ = TRUE" will plot the probability density function of the waiting time in queue. The user can access performance measures by name using the $ operator. Please consider the following example. 

```{r mm1summary, echo=FALSE }
mmc.summary <- function(lambda, mu, c, 
                        plot_pn = FALSE,
                        plot_waitSys = FALSE,
                        plot_waitQ = FALSE){
   if(c == 1){
      rho = lambda/mu
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")
      }
      c = 25*rho
      pn = integer(c)
      for(iter in 1:c){
         pn[iter] = (rho^iter)*(1-rho)
      }
      if(plot_pn == TRUE){
         num_ent = c(0, 1:(c-1))
         plot(num_ent, pn, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      t = seq(1, 12*rho, by = 1)
      waitSys_probabilities = (mu - lambda)*exp(-(mu - lambda)*t)
      if(plot_waitSys == TRUE){
         plot(t, waitSys_probabilities, main="Waiting Time in System",
              xlab="Time Spent in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      t = seq(1,12*rho, by = 1)
      waitQ_probabilities = c(1-rho, (mu*rho*(1-rho))*exp(-mu*(1 - rho)*t))
      if(plot_waitQ == TRUE){   
         plot(c(0, t), waitQ_probabilities, main= "Waiting Time in Queue",
              xlab="Time Spent in Queue",
              ylab="Probability", pch = 19, col = "blue")
      }
      L = rho/(1-rho)
      L_q = rho^2/(1-rho)
      W = 1/(mu - lambda)
      W_q = lambda/(mu*(mu - lambda))
      U = 1 - pn[1]
      I = 1 - rho
      
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, I, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = pn, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q,
                  'prob_T' = waitSys_probabilities, 'prob_Tq' = waitQ_probabilities))
   }
   else{
      rho = lambda/(c*mu)
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")}
      # a := offered load
      a = lambda/mu
      # find p0
      l = 0
      for(n in 0:(c-1)){
         l <- l + (a^n)/(factorial(n))
      }
      r = (a^c)/(factorial(c)*(1-rho))
      p0 = 1/(l + r)
      # find pn
      pn = c(p0)
      for(n in 1:c){
         pn = append(pn, ((a^n)/factorial(n))*p0)
      }
      for(n in (c+1):(10*c)){
         pn = append(pn, ((a^n)/(factorial(c)*c^(n-c)))*p0)
      }
      if(plot_pn == TRUE){
         num_ent = length(pn)
         plot(c(1:num_ent-1), pn, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      L_q = ((a^c)*rho/(factorial(c)*(1-rho)^2))*p0
      W_q = ((a^c)/(factorial(c)*(c*mu)*(1-rho)^2))*p0
      W = W_q + (1/mu)
      L = L_q + (lambda/mu)
      U = rho
      B = a
      I = p0
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Mean number busy servers", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, U, I, B, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = pn, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = I, 'B' = B, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex3}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 1, plot_pn = TRUE,
                 plot_waitQ = TRUE,
                 plot_waitSys = TRUE)
library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/1 Queues"))
```

<br />
Using the output we can find the probability that there are more than $k$ entities in the system using the formula $P(X \geq k) = \rho^{k}$. Suppose we wanted to find the probability that there are more than $k = 2$ entities in the system.

```{r ex4}
k = 2
prob_k_system <- (q$rho)^k
print(prob_k_system)
```

<br />
Recall that we can also find the following two probabilities. 
$$P(T > t) = e^{-\mu (1-\rho)t}$$
```{r ex5}
mu = 4.4545
t <- 2
pr <- exp(-mu*(1 - q$rho)*t)
print(pr)
```

$$P(T_q > t) = \rho e^{-\mu (1-\rho)t}$$
```{r ex6}
mu = 4.4545
t <- 2
pr2 <- (q$rho)*exp(-mu*(1 - q$rho)*t)
print(pr2)
```

<br />

Moving on, we consider Markovian queueing models with parallel channels: M/M/c/$\infty$/$\infty$ queues. 

```{r ex7}
q <- mmc.summary(lambda = 4, mu = 2, c = 3, plot_pn = TRUE)
library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/c Queues"))
```

<br />

You may have noticed that we did not plot the probability density functions for waiting times in queue or waiting times in system for the m/m/c queue. Instead we define two functions for m/m/c queues which return the cumulative probabilities $P\{T \geq t\}$ and $P\{T_q \geq t\}$. 

