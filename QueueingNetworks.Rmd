---
title: "Statistical Package for Queueing in R"
subtitle: Angyalka Valcsics and Pearl Armstrong
author: "University of Southern Maine"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    theme: sandstone
---
\tableofcontents 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- https://htmlpreview.github.io/?https://github.com/angyalkavalcsics/QueueingNetworks/blob/main/QueueingNetworks.html -->

We would like to dedicate the creation of this package to Professor Muhammad El-Taha. Thank you for always keeping us engaged, learning and laughing.

## How To Install

- To install a package from Github for the first time, first install the devtools package. This can be downloaded from the CRAN.
```{r install1, eval = FALSE}
install.packages("devtools", repos = "http://cran.us.r-project.org")
```
- Load the devtools package.
```{r install2, eval = FALSE}
library(devtools)
```
- Download the package from GitHub.
```{r install3, eval = FALSE}
install_github("angyalkavalcsics/QueueingNetworks/QinR")
```
- Load the package to use the functions.
```{r install4}
library (QinR)	
```
```{r printhelp, echo = FALSE}

help_console <- function(topic, package,
                         format=c("text", "html", "latex", "Rd"),
                         before=NULL, after=NULL) {
  # topic - the command for which help is required
  # package - the package name with the required topic
  # format - output format
  # before - place code before the output e.g. "<blockquote>"
  # after - place code after the output e.g. "</blockquote>"

  # based on code by Noam Ross
  #  http://www.noamross.net/archives/2013-06-18-helpconsoleexample/
  # Stéphane Laurent
  #  https://stackoverflow.com/questions/60468080/
  #   print-an-r-help-file-vignette-as-output-into-an-r-html-notebook
  # and Michael Sumner (mdsumner)
  #  https://stackoverflow.com/questions/7495685/
  #   how-to-access-the-help-documentation-rd-source-files-in-r

  format <- match.arg(format)
  if (!is.character(topic)) topic <- deparse(substitute(topic))
  db <- tools::Rd_db(package)
  helpfile <- db[paste0(topic, ".Rd")][[1]]

  hs <- capture.output(
    switch(
      format,
      text = tools::Rd2txt(helpfile),
      html = tools::Rd2HTML(
        helpfile,
        package = "",
        stages = c("install", "render")
      ),
      latex = tools::Rd2latex(helpfile),
      Rd = tools:::prepare_Rd(helpfile)
    )
  )
  if (format == "html") {
    i <- grep("<body>", hs)
    j <- grep("</body>", hs)
    hs <- hs[(i+1):(j-1)]
  }
  hs <- c(before, hs, after)
  hs <- cat(hs, sep = "\n")
  invisible(hs)
}
```
- Help files can be accessed using “?function name” and contain examples of how to use the functions. Please see the following example. 
```{r install5, eval = FALSE}
?mmc.summary
```

```{r showhelp, echo = FALSE, results = "asis"}
help_console(mmc.summary, "QinR", format = "html")
```
## Introduction

Queueing theory is the mathematical study of the formation and function of queues.  A basic queueing system is a system where entities arrive at a facility requiring some service, they join a line, and wait for service from one or more servers. The results of queueing analysis can be used to offer faster customer service, increase traffic flow, improve order shipments from a warehouse, or to design data networks and call centers.  We assume the reader has some previous knowledge of queueing networks. 

## Measures of System Performance

Variable | Definition
-------------------- | -------------
$\lambda$  | Average arrival rate
$S$  | Random service time
$\mu$  | Average service rate
$c$  | Number of servers
$r = \lambda / \mu$  | Offered load
$\rho = \lambda / c \mu$  | Traffic intensity or utilization
$T, T_{q}$  | Random time a customer spends in the system / queue
$W, W_{q}$  | Average time a customer spends in the system / queue
$N, N_{q}$  | Random number of customers in the system / queue
$L, L_{q}$  | Average number of customers in the system / queue

## Demonstration

<br />
The majority of the functions in this package ask for the average arrival rate and average service rate as inputs. For this reason we want to begin this documentation with a short example on calculating these values on realistic data. Additionally we want to discuss some challenging aspects of dealing with this sort of data. Let's just make some up for now.

```{r getthings}
admit <- data.frame("DateIn" = c("1/1/2021", "1/1/2021", "1/1/2021", "1/2/2021", "1/2/2021", "1/2/2021"), 
                    "TimeIn" = c(845, 1010, 1130, 1330, 1430, 1545), 
                    "DateOut" = c("1/7/2021", "1/3/2021", "1/4/2021", "1/1/2021", "1/7/2021", "1/6/2021"),
                    "TimeOut" = c("0115", "1200", "1745", "0850", "1200", "1430"))
print(admit)
# Notice that I intentionally made the data types different, you would think the csv file would have read in 
# evenly but it didn't :)
# sapply(log, class) # check data types
# First need to combine the data/time columns for arrival and departure into the system
# Pad time with zeros and convert char to int
newTimeIn <- gsub('^([0-9]{1,2})([0-9]{2})$', '\\1:\\2', sprintf('%04d',admit$TimeIn))
admit$TimeOut = as.integer(admit$TimeOut)
newTimeOut <- gsub('^([0-9]{1,2})([0-9]{2})$', '\\1:\\2', sprintf('%04d',admit$TimeOut))
# Format dates - capital Y for XXXX and lowercase y for XX type years
newDateIn = as.Date(admit$DateIn,'%m/%d/%Y')
newDateOut = as.Date(admit$DateOut,format='%m/%d/%Y')
# Combine into one column for calculations
admit$arrival <- with(admit, paste0(newDateIn, " ", newTimeIn))
admit$departure <- with(admit, paste0(newDateOut, " ", newTimeOut))
# as.POSIXct() is vectorized - see documentation online
# get arrivals in days - or whatever time unit you want
# treat this like a simulation where the earliest time begins at time unit 0
admit$arrival_days = as.numeric(as.POSIXct(admit$arrival, format = "%Y-%m-%d %H:%M")-as.POSIXct("2021-01-01 08:45", format = "%Y-%m-%d %H:%M"), units= "days")
admit$departure_days = as.numeric(as.POSIXct(admit$departure, format = "%Y-%m-%d %H:%M")-as.POSIXct("2021-01-01 08:45", format = "%Y-%m-%d %H:%M"), units= "days")
print(admit)
# service time in days
admit$service_days = admit$departure_days - admit$arrival_days
# oh yeah I snuck one in there - fix departure that occurs before arrival
# you could do a check to swap them if you trust the integrity of the data or
# just remove it altogether
admit = admit[admit["service_days"] > 0,]
print(admit)
# Now we need tidyverse, hopefully you have it installed
# install.packages("tidyverse")
suppressWarnings(suppressMessages(library("tidyverse")))
arrival_counts_days <- admit %>% group_by(DateIn) %>% count()
# Find discrete distribution of admits in days
count_days <- arrival_counts_days %>% pull(n)
# Find service distribution - really not helpful in this ex but with more data yes
hist(admit$service_days, main = "Distribution of Service Time", 
     xlab = "Service Time (days)")
# Compute average (effective) arrival rate
lambda = mean(count_days)
# compute average service time (days)
mean_service_time = mean(admit$service_days)
# average service rate
mu = 1/mean_service_time
print(mu)
print(lambda)
                  
```

<br />
That's it for now, more to come in the future.

## M/M/c Markovian model

<br />
Consider an M/M/1 Markovian model. Given inputs arrival rate, service rate, and number of servers $c = 1$ the function mmc.summary() returns a data frame of performance measures for the queue and an array with the discrete distribution for the number of customers in system. Additionally, by entering "plot_pn = TRUE", the function will plot the distribution of customers/jobs in system. For m/m/1 queues, by entering "plot_waitSys = TRUE" the function will plot the probability density function of the waiting time in system and similarly "plot_waitQ = TRUE" will plot the probability density function of the waiting time in queue. The variable tol is the stopping criteria for finding the probability distribution of customers in the system. That is, the function stops finding additional probabilities when $\sum p_n < 1 - tol$. The user can access performance measures by name using the $ operator as demonstrated above. Please consider the following example. 

```{r mm1summary, echo=FALSE }
mmc.summary <- function(lambda, mu, c, tol, 
                        plot_pn = FALSE,
                        plot_waitSys = FALSE,
                        plot_waitQ = FALSE){
   if(c == 1){
      rho = lambda/mu
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")
      }
   
      p_n = c()
      iter = 0
      while(sum(p_n) < (1-tol)){
         p_n = append(p_n, (rho^iter)*(1-rho))
         iter = iter + 1
      }
      if(plot_pn == TRUE){
         
         num_ent = c(0, 1:(length(p_n)-1))
         plot(num_ent, p_n, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      t = seq(1, 12*rho, by = 1)
      waitSys_probabilities = (mu - lambda)*exp(-(mu - lambda)*t)
      if(plot_waitSys == TRUE){
         plot(t, waitSys_probabilities, main="Waiting Time in System",
              xlab="Time Spent in System",
              ylab="Probability", pch = 19, col = "blue")
         lines(t, waitSys_probabilities, type = "b", col = "blue")
      }
      t = seq(1,12*rho, by = 1)
      waitQ_probabilities = c(1-rho, (mu*rho*(1-rho))*exp(-mu*(1 - rho)*t))
      if(plot_waitQ == TRUE){   
         plot(c(0, t), waitQ_probabilities, main= "Waiting Time in Queue",
              xlab="Time Spent in Queue",
              ylab="Probability", pch = 19, col = "blue")
         lines(t, (mu*rho*(1-rho))*exp(-mu*(1 - rho)*t), type = "b", col = "blue")
      }
      L = rho/(1-rho)
      L_q = rho^2/(1-rho)
      W = 1/(mu - lambda)
      W_q = lambda/(mu*(mu - lambda))
      U = 1 - p_n[1]
      I = 1 - rho
      
      rnames <- rbind("Utilization", 
                      "Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", "Mean number in queue")
      res <- data.frame(cbind(rnames, round(rbind(rho, I, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res, 
                  'rho' = rho, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q,
                  'prob_T' = waitSys_probabilities, 'prob_T_q' = waitQ_probabilities))
   }
   else{
      rho = lambda/(c*mu)
      if(rho < 1) print("System is stable.")
      else{stop("System is unstable.")}
      # a := offered load
      a = lambda/mu
      # find p0
      l = 0
      for(n in 0:(c-1)){
         l <- l + (a^n)/(factorial(n))
      }
      r = (a^c)/(factorial(c)*(1-rho))
      p0 = 1/(l + r)
      # find pn
      p_n = c(p0)
      for(n in 1:c){
         p_n = append(p_n, ((a^n)/factorial(n))*p0)
      }
      
      iter = c+1
      while(sum(p_n) < (1-tol)){
         p_n = append(p_n, ((a^iter)/(factorial(c)*c^(iter-c)))*p0)
         iter = iter + 1
      }
      
      if(plot_pn == TRUE){
         num_ent = length(p_n)
         plot(c(1:num_ent-1), p_n, main="Distribution of Number of Customers in System",
              xlab="Number of customers in System",
              ylab="Probability", pch = 19, col = "blue")
      }
      L_q = ((a^c)*rho/(factorial(c)*(1-rho)^2))*p0
      W_q = ((a^c)/(factorial(c)*(c*mu)*(1-rho)^2))*p0
      W = W_q + (1/mu)
      L = L_q + (lambda/mu)
      U = rho
      B = a
      I = p0
      delayed = ((a^c)*p0)/(factorial(c)*(1-rho))
      rnames <- rbind("Utilization", 
                      "Idle time", "Mean number busy servers", "Mean time in system",
                      "Mean time in queue", "Mean number in system", "Mean number in queue",
                      "Probability arriving entity waits in queue")
      res <- data.frame(cbind(rnames, round(rbind(U, I, B, W, W_q, L, L_q, delayed), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res,
                  'rho' = rho, 'p0' = I, 'r' = B, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex3}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 1, 
                 tol = 0.01,
                 plot_pn = TRUE,
                 plot_waitQ = TRUE,
                 plot_waitSys = TRUE)

library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/1 Queues"))
```

<br />
Using the output we can find the probability that there are more than $k$ entities in the system using the formula $P(X \geq k) = \rho^{k}$. Suppose we wanted to find the probability that there are more than $k = 2$ entities in the system.

```{r ex4}
k = 2
prob_k_system <- (q$rho)^k
print(prob_k_system)
```

<br />
Recall that we can also find the following two probabilities. 
$$P(T > t) = e^{-\mu (1-\rho)t}$$
```{r ex5}
mu <- 4.4545
t <- 2
pr <- exp(-mu*(1 - q$rho)*t)
print(pr)
```

$$P(T_q > t) = \rho e^{-\mu (1-\rho)t}$$
```{r ex6}
mu <- 4.4545
t <- 2
pr2 <- (q$rho)*exp(-mu*(1 - q$rho)*t)
print(pr2)
```

<br />

Moving on, we consider Markovian queueing models with parallel channels: M/M/c/$\infty$/$\infty$ queues. 

```{r ex7}
q <- mmc.summary(lambda = 4, mu = 4.4545, c = 2, tol = 0.01, plot_pn = TRUE)

library(gt)
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for M/M/c Queues"))
```

<br />

You may have noticed that we did not plot the probability density functions for waiting times in queue or waiting times in system for the m/m/c queue. Instead we will just demonstrate how to find the cumulative probability $P\{T_q \leq t\}$. 

$$P(T_q \leq t) = 1 - \dfrac{r^{c}p_{0}}{c!(1-\rho)} e^{-(c \mu - \lambda)t}$$
Where $r = \lambda / \mu$ and $\rho = \lambda / (c\mu)$. Then 
```{r ex9}
# given 
lambda <- 4
mu <- 4.4545
c <- 2
t <- 0.05

# performance results
rho <- q$rho
p0 <- q$p0
r <- q$r

pr <- 1 - ((r^c * p0)/(factorial(c)*(1 - rho)))*exp(-(c*mu - lambda)*t)
print(pr)
```

## Erlang Loss Models

This system is the oldest and the most famous system in queueing theory. Suppose that entities arrive according to a Poisson process and the service times are exponentially distributed. If all servers are busy when a new entity arrives, it will be lost because the system is full. The following function takes, as arguments, the arrival rate (lambda), the service rate (mu), and the number of servers (c). Additionally, with the Boolean set to true, the function will plot the number of servers from 1 to the number of servers specified and the probability of blocking.

<br />

Please keep in mind that in these formulas, the quantities for blocking probability are theoretical averages that are approached, as a limit, under the assumption that the queue operates for a very long period of time, without any change to the queue parameters (number of servers, arrival rate, service rate).

<br />

Finally, as you will come to expect from this package, the function returns a table of results. This will be the blocking probabilities, the effective arrival rate, the number of entities turned away per unit time (respective to your arrival and service rates), the average number of entities in the system, and the utilization fraction. Let's see an example. 

```{r erlangloss, echo=FALSE}
erlangloss.summary <- function(lambda, mu, c, plot_blocking = TRUE){ 
   # r := offered load
   r <- lambda/mu
   # recursively calculate the fraction of entities blocked
   # here n represents the number of servers
   # B := blocking probabilities where index is the num servers
   B <- rep(1, c+1)
   for(n in 1:c) {
      x <- r*B[n]
      B[n+1] <- x/(n + x)
   }
   blocking <- round(B[2:length(B)], 3)
   num_servers <- seq(1, c, 1)   
   if(plot_blocking == TRUE){
      plot(num_servers, blocking, main = "Blocking Probability",
           xlab = "Number of servers", ylab = "Probability of blocking",
           pch = 19, col = "blue")
   }
   # abline(h = 0.05)
   # Effective arrival rate per day
   lambda_eff <- round(lambda*(1-blocking),3)
   # Number of entities turned away per time unit
   turned_away <- lambda*blocking
   # Average number of entities in system
   NS <- r*(1-blocking)
   # Utilization fraction := average fraction of time that each server is busy
   U <- (NS/num_servers)
   # In these formulas, the quantities for B are theoretical averages 
   # that are approached as a limit under the assumption that the queue 
   # operates for a very long period of time without any change to the 
   # queue parameters (number of servers, arrival rate, service rate).
   res <- data.frame(round(cbind(num_servers, blocking, lambda_eff, turned_away,
                                               NS, U), 3))
   return(list('res' = res, 'blocking_probabilities' = blocking,
               'lambda_eff' = lambda_eff, 'turned_away' = turned_away, 'L' = NS, 'Utilization' = U))
}
```
   
```{r ex loss, echo=TRUE}
lambda <- 6
mu <- 3
c <- 4

erlangloss.summary(lambda, mu, c, plot_blocking = TRUE)

```

## Single-Server Finite Population Queue

```{r finitesummary, echo=FALSE}
########################################################################
# Finite Population Single Server Model (N >= 1)
########################################################################
# lambda := arrival rate
# mu := service rate
# N := system capacity
finitepopulation.summary <- function(lambda, mu, N){
   a <- lambda / mu
   if(N <= 100){
      bottleneck <- matrix(1, nrow = N+1, ncol = 1)
      for (n in 1:N) {
         bottleneck[n+1,1] <- bottleneck[n, 1]*(N-n+1)*a
      }
      p0 <- (1/sum(bottleneck))
      p_n <- c(bottleneck*p0)
      
      L_q <- N - ((lambda + mu)/lambda)*(1-p0)
      L <- N - (mu/lambda)*(1-p0)
      W <- N/(mu*(1-p0)) - 1/lambda
      W_q <- L_q/(lambda*(N-L))
      lambda_eff <- mu*(1-p0)
      I <- p0
      rnames <- rbind("Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", 
                      "Mean number in queue", "Effective arrival rate")
      res <- data.frame(cbind(rnames, round(rbind(I, W, W_q, L, L_q, lambda_eff), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res, 'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 
                  'L_q' = L_q, 'lambda_eff' = lambda_eff))
   }
   else{
      # 'Multiple Precision Floating-Point Reliably'
      # Pro: we can do this for very large N
      # Con: we have to depend on an external package that may change
      
      if("Rmpfr" %in% rownames(installed.packages()) == FALSE) {install.packages("Rmpfr")}
      suppressWarnings(suppressMessages(library(Rmpfr)))
      bottleneck <- mpfr(matrix(1, nrow = N+1, ncol = 1), 300)
      for (n in 1:N) {
         bottleneck[n+1,1] <- bottleneck[n, 1]*mpfr((N-n+1)*a, 300)
      }
      p0 <- (1/sum(bottleneck))
      p_n <- c(bottleneck*p0)
      p_n <- as.numeric(p_n)
      
      L_q <- as.numeric(N - ((lambda + mu)/lambda)*(1-p0))
      L <- as.numeric(N - (mu/lambda)*(1-p0))
      W <- as.numeric(N/(mu*(1-p0)) - 1/lambda)
      W_q <- as.numeric(L_q/(lambda*(N-L)))
      lambda_eff <- as.numeric(mu*(1-p0))
      I <- as.numeric(p0)
      rnames <- rbind("Idle time", "Mean time in system",
                      "Mean time in queue", "Mean number in system", 
                      "Mean number in queue", "Effective arrival rate")
      res <- data.frame(cbind(rnames, round(rbind(I, W, W_q, L, L_q, lambda_eff), 4)))
      names(res)<- c("Definition", "Result")
      return(list('pn' = p_n, 'res' = res,'p0' = I, 'W' = W, 'W_q' = W_q, 'L' = L, 
                  'L_q' = L_q, 'lambda_eff' = lambda_eff))
   }
}
```

Suppose we had a system where there is only one server and a finite population of $N$ customers which all have the same arrival rate $\lambda$. We can use the finitepopulation.summary() function. This function takes as inputs the arrival rate, the service rate, and the size of the finite population $N$. When $N$ is larger than 100, we employ the Rmpfr library which performs multiple-precision floating-point computations in an efficient way. The function will check if the user has this package installed. If not, it will install the package then load the library. 

<br />

Be patient with us as we discuss the nice way we avoided calculating factorials in this function. For a finite population single-server model, we have that the probability that there are no customers in the system is

$$p_0 = \left[ \sum_{n = 0}^{N} \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} \right]^{-1}$$
When $n=0$, let
$$S_{0} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{0}}{N!} = 1$$
When $n=1$,

$$S_{1} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)! \left(\dfrac{\lambda}{\mu}\right)^{1}}{(N-1)!} = N \left(\dfrac{\lambda}{\mu}\right)^{1} = S_{0} \cdot N \cdot \dfrac{\lambda}{\mu}$$

When $n=2$,

$$S_{2} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)(N-2)! \left(\dfrac{\lambda}{\mu}\right)^{2}}{(N-2)!} = N(N-1) \left(\dfrac{\lambda}{\mu}\right)^{2} = S_{1} \cdot (N-1) \cdot \dfrac{\lambda}{\mu}$$
When $n=3$,

$$S_{3} = \dfrac{N! \left(\dfrac{\lambda}{\mu}\right)^{n}}{(N-n)!} = \dfrac{N(N-1)(N-2)(N-3)! \left(\dfrac{\lambda}{\mu}\right)^{3}}{(N-3)!} = N(N-1)(N-2) \left(\dfrac{\lambda}{\mu}\right)^{3} = S_{2} \cdot (N-2) \cdot \dfrac{\lambda}{\mu}$$

We continue on in this way, storing each value, using the previous one to calculate the next value up until the $N^{th}$ value. This will ultimately make up the sum that is used to calculate $p_0$. Then

$$p_{0} = \left[ \sum_{n=0}^{N} S_{n} \right]^{-1}$$
This value is then used to calculate all performance measures. Let's see an example for how the function works.

```{r finitesummaryex1}
lambda <- 0.025
mu <- 1
N <- 4
q <- finitepopulation.summary(lambda, mu, N)
pt <- q$res
pt %>%
   gt() %>%
   tab_header(
      title = md("Performance Measures for Single-Server Finite Population Queue"))
```

<br />

For $N > 100$, we avoid floating-point error.
```{r finitesummaryex2}
lambda <- 10
mu <- 5000
N <- 300
q <- finitepopulation.summary(lambda, mu, N)
pt <- q$res
pt %>%
   gt() %>%
   tab_header(
      title = md("Performance Measures for Single-Server Finite Population Queue"))

# See that this sum is equal to 1 :)
sum(q$pn)
```

## The Birth Death Process

Suppose you want to solve the flow balance equation for a birth-death type queue with finite capacity $n$. Given an array of arrival (birth) rates $\lambda = (\lambda_{0}, \lambda_{1}, \cdots)$ and an array of service (death) rates $\mu = (\mu_{1}, \mu_{2}, \cdots)$, the function BD.solve($\lambda$, $\mu$) will return $\{p_n, n \geq 0\}$, the discrete distribution of number of customers in system. Please see the following example with $\lambda = (3, 2, 1)$ and $\mu = (1, 2, 2)$.

```{r BD.solve, echo=FALSE }
BD.solve <- function(lambda, mu){
   if(length(lambda) != length(mu))
   {
      stop('Arrays must have equal length')
   }
   temp = lambda/mu
   k = length(lambda)
   s = 0
   for(j in 1:k){
      s = s + prod(temp[1:j])
   }
   p0 = 1/(1+s)
   pn = c(p0)
   for(j in 1:k){
      pn <- append(pn, temp[j]*pn[j])
   }
   return(pn)
}
```

```{r ex8}
mu <- c(1, 2, 2)
lambda <- c(3, 2, 1)

pn = BD.solve(lambda, mu)
print(pn)
```
Where the first element corresponds to $p_0$, the second to $p_1$, and so on. 


## Open Single-Server Jackson Networks

Suppose we have an open Jackson network where entities may arrive from the outside at any node according to a Poisson process and entities are serviced according to an exponential distribution. There is no limit on queue capacity at any node and there is a probability, possibly nonzero, that an entity will leave the network at some node $i$ upon completion of service. We can use the function ojn.summary(R, gamma, mu, maxMarginalProb) to find performance measures for this system. This stands for 'Open Jackson Network Summary'. This function takes as inputs the routing matrix R, the mean arrival rate to each node gamma, the mean service rate of each node mu, and the max number of marginal probabilities you would like returned for each node. Please keep in mind that in order to avoid rounding error, it is necessary to keep the probabilities in the routing matrix as fractions if they are, for example, non-terminating, recurring decimal numbers. 
```{r ojn.summary, echo=FALSE}
ojn.summary <- function(R, gamma, mu, maxMarginalProb){
   n = nrow(R)
   m = ncol(R)
   K = length(mu)
   I = diag(x = 1, nrow = n, ncol = m)
   Q = I - R
   lambda_i = gamma%*%(solve(Q))
   rho_i = lambda_i / mu
   I_i = 1-rho_i
   Lq_i = (rho_i)^2 / I_i
   L_i = (rho_i)/ I_i
   W_i = L_i / lambda_i
   Wq_i = Lq_i / lambda_i
   L = sum(L_i)
   W = L/(sum(gamma))
   # find marginals
   p_n = matrix(0, maxMarginalProb, K)
   p_n[1,] = 1-rho_i
   for (i in 1:(maxMarginalProb-1)) {
      p_n[i+1,]=(rho_i^i)*(1-rho_i)
   }
   rnames <- rbind("Node i throughput", "Utilization at node i", 
                   "Probability node i is idle", "Mean time at node i","Mean number at node i",
                   "Mean queue time at node i", "Mean number in queue at node i")
   res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i, Wq_i, Lq_i), 4)))
   names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
   return(list('marginal_probabilities' = p_n, 'res' = res,
               'throughput_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
               'W_i' = W_i, 'L_i' = L_i, 'Wq_i' = Wq_i, 'Lq_i' = Lq_i,
               'W' = W, 'L' = L))
}
```

```{r ex1 ojn}
R = matrix(c(0, 0.45, 0.55,
             0, 0, 0.02,
             0, 0.01, 0), 
           nrow = 3, ncol = 3, byrow = TRUE)
gamma = c(1, 5, 0)
mu = c(20, 10, 3)

q <- ojn.summary(R, gamma, mu, 15)

qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for Open Jackson Networks"))
q$marginal_probabilities

```

## Closed Single-Server Jackson Networks

In a closed Jackson network, there is no input rate from the outside world. Essentially, this is equivalent to a system where $N$ entities continuously travel inside the network. Suppose we have the following routing matrix and we need to solve $vR = v$ such that $\sum v_i = 1$. We can use the function solverouting() to accomplish this. The only input necessary is the routing matrix. 
```{r solve routing matrix, echo=FALSE}
# find v given the routing matrix R
solverouting <- function(R){
   n = nrow(R)
   m = ncol(R)
   I = diag(x = 1, nrow = n, ncol = m)
   Q = R - I
   Q = cbind(Q, rep(1, n))
   b = matrix(c(rep(0, n), 1), nrow = 1, ncol = (m+1))
   v = (b%*%t(Q))%*%solve(Q%*%t(Q))
}

```
```{r cjn ex 1}
# find v given the routing matrix
R = matrix(c(0, 0.75, 0.25,
             0.6666666667, 0, 0.3333333333, 
             1, 0, 0), nrow = 3, ncol = 3, byrow = TRUE)
v = solverouting(R)
print(v)
```

Now, let's get the performance measures for each node in this network using the function cjn.summary(v, N, K, convolution = TRUE). This stands for 'Closed Jackson Network Summary'. The necessary inputs are v, the solution to $vR = v$ such that $\sum v_i = 1$, the given service rates, N the number of customers in the system, K the number of nodes in the network, and a boolean convolution. When convolution is set to true, the function uses Buzen's algorithm to solve for the summary statistics. Otherwise the function will use Mean Value Analysis. Using the same routing matrix as before let's see an example, first with convolution. 

```{r cjn, echo=FALSE}
# v := solution to vR = v
# N := number of customers in the network
# K := number of nodes
# if convolution = TRUE, uses convolution algorithm,
# else uses Mean Value Analysis.
cjn.summary <- function(v, mu, N, K, convolution = TRUE){
   if(convolution == TRUE){
      # Find tau_1, ..., tau_k
      tau = v/mu
      # Find G
      G = matrix(1, nrow = (N+1), ncol = K)
      for(i in 2:(N+1)){
         G[i, 1] = tau[1]^(i-1)
      }
      # i iterates over rows
      for(i in 2:(N+1)){
         # j iterates over columns
         for(j in 2:(K)){
            G[i, j] = G[i, j-1] + tau[j]*G[i-1, j]
         }
      }
      system_throughput = G[N,K]/G[(N+1), K]
      lambda_i = v*system_throughput
      rho_i = tau*system_throughput
      I_i = 1-rho_i
      # Find L_i, W_i
      p_bar = matrix(0, K, K)
      # iterates over n_i
      for(n_i in 1:N){
         # iterates over tau_i
         for(i in 1:K){
            p_bar[n_i, i] = (tau[i]^n_i)*(G[((N+1)-n_i),K]/G[(N+1), K])
         }
      }
      L_i = colSums(p_bar)
      W_i = L_i/lambda_i
      Lq_i = L_i - (lambda_i / mu)
      Wq_i = Lq_i / lambda_i
      p = matrix(0, N+1, K)
      # iterates over n_i
      for(n_i in 0:(N-1)){
         # iterates over tau_i
         for(i in 1:K){
            p[(n_i + 1), i] = (tau[i]^n_i)*((G[((N+1)-n_i),K] - tau[i]*G[((N+1)- n_i - 1),K])/G[(N+1), K])
         }
      }
      p[(N+1),] = (tau^N)/G[(N+1), K]
      
      
      rnames <- rbind("Node i throughput", "Utilization at node i", 
                      "Probability node i is idle", "Mean time at node i","Mean number at node i",
                      "Mean queue time at node i", "Mean number in queue at node i")
      res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i, Wq_i, Lq_i), 4)))
      names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
      row.names(res) <- seq(1:7)
      return(list('marginal_probabilities' = p, 'res' = res, 'system_throughput' = system_throughput,
                  'lambda_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
                  'W_i' = W_i, 'L_i' = L_i, 'Lq_i' = Lq_i, 'Wq_i' = Wq_i))
   }
   ################################################################################
   # Mean Value Analysis algorithm
   else{
      # Find tau_1, ..., tau_k
      tau = v/mu
      # first row corresponds to L_{i}(0)
      # second to L_{i}(1) and so on
      L = matrix(0, N, K)
      # stores the W_{i}(n) values
      W = matrix(0, N, K)
      # stores the lambda(n) values
      lambda = rep(0, N)
      for(n in 1:N){
         if(n == 1){
            for(i in 1:K){
               W[n, i] = (1/mu[i])
            }
         }
         else{
            for(i in 1:K){
               W[n, i] = (1/mu[i])*(1 + L[n-1, i])
            }
         }
         lambda[n] = n/(sum(v*W[n,]))
         for(j in 1:K){
            L[n, j] = lambda[n]*v[j]*W[n, j]
         }
      }
      # Output at convergence:
      W_i = W[N,]
      L_i = L[N,]
      # Little's law : L = lambda * W
      # node i throughput
      lambda_i = L_i/W_i
      Lq_i = L_i - (lambda_i / mu)
      Wq_i = Lq_i / lambda_i
      # node i utilization
      rho_i = lambda_i / mu
      I_i = 1 - rho_i
      system_throughput = mean(rho_i/tau)
      rnames <- rbind("Node i throughput", "Utilization at node i", 
                      "Probability node i is idle", "Mean time at node i","Mean number at node i",
                      "Mean queue time at node i", "Mean number in queue at node i")
      res <- data.frame(cbind(rnames, round(rbind(lambda_i, rho_i, I_i, W_i, L_i,  Wq_i, Lq_i), 4)))
      names(res)<- c("Definition", sprintf("node%2d",seq(1:K)))
      row.names(res) <- seq(1:7)
      return(list('res' = res, 'system_throughput' = system_throughput,
                  'lambda_i' = lambda_i, 'rho_i' = rho_i, 'idle' = I_i, 
                  'W_i' = W_i, 'L_i' = L_i, 'Lq_i' = Lq_i, 'Wq_i' = Wq_i))
   }
}

```
```{r cjn ex 2}
# given service rates
mu = c(4, 1, 3)
# number of customers in the system
N = 3
# number of nodes in the network
K = 3

q <- cjn.summary(v, mu, N, K, convolution = TRUE)

qt <- q$res
      qt %>%
         gt() %>%
         tab_header(
            title = md("Measures of Performance for Closed Jackson Networks"))
# marginal distribution 
print(q$marginal_probabilities)
# system throughput
print(q$system_throughput)
      
```

Next we do this using the MVA algorithm. We recommend for the user to use convolution. For large systems it is more efficient and you can get the marginal distributions--whereas for this algorithm we do not include the marginal distributions. 

```{r cjn ex 3}
# using same inputs as above
q <- cjn.summary(v, mu, N, K, convolution = FALSE)

qt <- q$res
      qt %>%
         gt() %>%
         tab_header(
            title = md("Measures of Performance for Closed Jackson Networks"))
# system throughput
print(q$system_throughput)
      
```

## Notation and relationships for G/G/1 queue

In this demonstration, we will use the random events of arrivals and service completions from a general distribution to demonstrate the development of a queue over time. In event-oriented bookkeeping, the system state is only updated when events occur. Either when customers/jobs arrive or depart. Suppose we observe a system, recording the times of arrival and service for each entity. An alternative to recording arrival times is to record the time between arrivals. With this information we can calculate measures of performance (see table above) and find other bookkeeping results such as:

Variable | Definition | Sample relationship
------------- | ------------- | -------------
$A^{(n)}$  | Arrival time of cust. $n$ | 
$S^{(n)}$  | Service time of cust. $n$ |
$T^{(n)}$  | Inter. time cust. $n$ and $n+1$ | $T^{(n)} = A^{(n+1)} - A^{(n)}$
$U^{(n)}$  | Time cust. $n$ starts service | $U^{(n+1)} = max\{D^{(n)}, A^{(n+1)}\}$
$D^{(n)}$  |Departure time of cust. $n$ | $D^{(n)} = U^{(n)} + S^{(n)}$
$W_{q}^{(n)}$  | Time in queue of cust. $n$ | $W_{q}^{(n)} = U^{(n)} - A^{(n)}$
$W^{(n)}$  | Time in system of cust. $n$ | $W^{(n)} = W_{q}^{(n)} + S^{(n)}$

The analysis is obtained under the assumption of a single server with FCFS discipline. No assumptions are required on the probability laws for the interarrival times or service times. 

The gg1.summary() function takes three inputs. First an input of either the arrival times or the interarrival times, the service times, and a Boolean--set interarrival = TRUE if the first input is interarrival times. The function outputs a data frame with the bookkeeping values for each entity and a data frame which holds some performance measures.The user can access performance measures by name using the $ operator. Please see the examples that follow.

```{r gg1summary, echo=FALSE }
gg1.summary <- function(arrivals, service_times, interarrival = FALSE){
   if(length(arrivals) != length(service_times))
   {
      stop('Arrays must have equal length')
   }
   n <- length(arrivals)
   if(interarrival == TRUE){
      interarrival_times = c(arrivals, NA)
      service_times = c(NA, service_times)
      arrival_times = c(0)
      arrival_times <- append(arrival_times, interarrival_times[1])
      for(i in 2:n){
         arrival_times <- append(arrival_times, arrival_times[i] + interarrival_times[i])
      }
      starts_service <- c(NA, arrival_times[2])
      departure_times <- c(NA, service_times[2] + arrival_times[2])
      for(i in 3:(n+1)){
         starts_service <- append(starts_service, max(departure_times[i-1], arrival_times[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- c(starts_service - arrival_times)
      system_times <- c(queue_times + service_times)
      df <- data.frame(customers = c(0, seq(1:n)), arrival_times = arrival_times,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times, na.rm = TRUE)
      W <- mean(system_times, na.rm = TRUE)
      lambda <- n/departure_times[n+1]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
      
   }
   else{
      interarrival_times <- c(diff(arrivals), NA)
      starts_service <- c(0)
      departure_times <- c(service_times[1] - arrivals[1])
      for(i in 2:n){
         starts_service <- append(starts_service, max(departure_times[i-1], arrivals[i]))
         departure_times <- append(departure_times, starts_service[i] + service_times[i])
      }
      queue_times <- starts_service - arrivals
      system_times <- queue_times + service_times
      df <- data.frame(customers = seq(1:n), arrivals = arrivals,
                       service_times = service_times, 
                       interarrival_times = interarrival_times, starts_service = starts_service,
                       departure_times = departure_times, queue_times = queue_times, 
                       system_times = system_times)
      
      W_q <- mean(queue_times)
      W <- mean(system_times)
      lambda <- n/departure_times[n]
      L_q <- lambda*W_q
      L <- lambda*W
      rho <- L - L_q
      p0 <- 1 - rho
      rnames <- rbind("Average arrival rate", "Utilization", 
                      "Idle time", "Average time in system",
                      "Average time in queue", "Average number in system", "Average number in queue")
      res <- data.frame(cbind(rnames, round(rbind(lambda, rho, p0, W, W_q, L, L_q), 4)))
      names(res)<- c("Definition", "Result")
      return(list('bookkeeping' = df, 'res' = res, 'lambda' = lambda,
                  'rho' = rho, 'p0' = p0, 'W' = W, 'W_q' = W_q, 'L' = L, 'L_q' = L_q))
   }
}
```

```{r ex1}
# Arrival times
arrival <- c(0, 2, 3, 6, 7, 8, 12, 14, 19, 20, 24, 26)
# Service times
service <- c(1, 3, 6, 2, 1, 1, 1, 2, 5, 1, 1, 3)
# Run gg1.summary() on this data
q <- gg1.summary(arrival, service)
# Use gt package for nice tables
library(gt)
# Get bookkeeping results
pt <- q$bookkeeping
pt %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt <- q$res
qt %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

<br />
Now suppose that we only had data on the interarrival times and the service times. 

```{r ex2}
# Interarrival times
inter <- c(1, 9, 6, 4, 7, 9, 5, 8, 4, 10, 6, 12, 6, 8, 
           9, 5, 7, 8, 8, 7)
# Service times
serv <- c(3, 7, 9, 9, 10, 4, 8, 5, 5, 3, 6, 3, 5, 4, 
          9, 9, 8, 6, 8, 3)
# Run gg1.summary() on this data
q2 <- gg1.summary(inter, serv, interarrival = TRUE)
pt2 <- q2$bookkeeping
pt2 %>%
   gt() %>%
   tab_header(
      title = md("Event-Oriented Bookkeeping for G/G/1 Queues"))
# Get performance results
qt2 <- q2$res
qt2 %>%
   gt() %>%
   tab_header(
      title = md("Measures of Performance for G/G/1 Queues"))

```

<br />

<br />
Please cite this package in the following way.

```{r citeme, echo = TRUE}
citation("QinR")
```

